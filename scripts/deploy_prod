#!/usr/bin/env bash

set -e

unset KUBECONFIG
unset KUBE_CA_PEM_FILE
unset KUBE_URL
unset KUBE_CA_PEM
unset KUBE_TOKEN

#cat ~/.kube/config
CI_IMAGE_VERSION="feature-deploy-prod"
URL="api.new.flat.memleak.pl"
IP_NAME="flat-ip"


KUBE_NAMESPACE=api
TRACK="production"
name="api-production"

replicas="1"

echo "Configuring database..."
mysql_name="mysql"
mysql_app="mysql"
migrate_db_name="migrate-db"
MYSQL_USER="flat"
MYSQL_DATABASE="flat"

DJANGO_SECRET_KEY="$PROD_DJANGO_SECRET_KEY"
GCM_KEY="$PROD_GCM_KEY"
FCM_SERVER_KEY="$PROD_FCM_SERVER_KEY"
MYSQL_PASSWORD="$PROD_MYSQL_PASSWORD"

if [ -z "$DJANGO_SECRET_KEY" ]; then echo "Missing DJANGO_SECRET_KEY";  exit 1; fi 
if [ -z "$GCM_KEY" ]; then echo "Missing GCM_KEY";  exit 1; fi
if [ -z "$FCM_SERVER_KEY" ]; then echo "Missing FCM_SERVER_KEY";  exit 1; fi
if [ -z "$MYSQL_PASSWORD" ]; then echo "Missing MYSQL_PASSWORD";  exit 1; fi

cat <<EOF | kubectl apply -n $KUBE_NAMESPACE --force -f -
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: mysql-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: $mysql_name
  namespace: $KUBE_NAMESPACE
  labels:
    app: $mysql_app
    tier: database
spec:
  replicas: 1
  selector:
    matchLabels:
      app: $mysql_app
      tier: database
  template:
    metadata:
      labels:
        name: $mysql_name
        app: $mysql_app
        tier: database
    spec:
      imagePullSecrets:
      - name: gitlab-registry-pernament
      containers:
      - name: app
        image: mariadb:10
        imagePullPolicy: Always
        env:
        - name: MYSQL_USER
          value: "$MYSQL_USER"
        - name: MYSQL_PASSWORD
          value: "$MYSQL_PASSWORD"
        - name: MYSQL_DATABASE
          value: "$MYSQL_DATABASE"
        - name: MYSQL_RANDOM_ROOT_PASSWORD
          value: "yes"
        volumeMounts:
        - name: mysql-data
          mountPath: "/var/lib/mysql"
        ports:
        - name: mysql
          containerPort: 3306
      volumes:
      - name: mysql-data
        persistentVolumeClaim:
          claimName: mysql-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: $mysql_name
  namespace: $KUBE_NAMESPACE
  labels:
    app: $mysql_app
spec:
  ports:
    - name: mysql
      port: 3306
      targetPort: mysql
  selector:
    app: $mysql_app
    tier: database
EOF

echo "Waiting for deployment..."
kubectl rollout status -n "$KUBE_NAMESPACE" -w "deployment/$mysql_name"


echo "Migrating database..."
cat <<EOF | kubectl apply -n $KUBE_NAMESPACE --force -f -
apiVersion: batch/v1
kind: Job
metadata:
  name: $migrate_db_name
  namespace: $KUBE_NAMESPACE
  labels:
    track: "$TRACK"
    pipeline_id: "$CI_PIPELINE_ID"
    build_id: "$CI_BUILD_ID"
spec:
  backoffLimit: 4
  template:
    metadata:
      labels:
        name: $migrate_db_name
        track: "$TRACK"
    spec:
      restartPolicy: Never
      containers:
      - name: app
        image: "$CI_REGISTRY_IMAGE:$CI_IMAGE_VERSION"
        imagePullPolicy: Always
        command: ["bash", "scripts/docker_entry_migration", "debug"]
        env:
        - name: CI_BUILD_ID
          value: "$CI_BUILD_ID"
        - name: RAILS_SECRET_KEY
          value: "$DJANGO_SECRET_KEY"
        - name: RAILS_DEBUG 
          value: "False"
        - name: RAILS_ALLOWED_HOST
          value: "*"
        - name: RAILS_GCM_KEY
          value: "$GCM_KEY"
        - name: RAILS_CORS_ALLOW_ALL
          value: "True"
        - name: RAILS_CORS_WHITELIST
          value: ""
        - name: RAILS_DB_NAME
          value: "$MYSQL_DATABASE"
        - name: RAILS_DB_USER 
          value: "$MYSQL_USER"
        - name: RAILS_DB_PASS
          value: "$MYSQL_PASSWORD"
        - name: RAILS_DB_HOST
          value: "$mysql_name"
        - name: RAILS_DB_PORT
          value: "3306"
        - name: FCM_SERVER_KEY
          value: "$FCM_SERVER_KEY"
EOF

kubectl -n "$KUBE_NAMESPACE" get jobs

echo "Wait for migration"
until kubectl -n "$KUBE_NAMESPACE" get jobs $migrate_db_name -o jsonpath='{.status.conditions[?(@.type=="Complete")].status}' | grep True ; do echo -n '.'; sleep 1 ; done

echo "Deleting job"
kubectl -n "$KUBE_NAMESPACE" delete jobs/$migrate_db_name

echo "Deploying $CI_ENVIRONMENT_SLUG (track: $TRACK, replicas: $replicas) with $CI_REGISTRY_IMAGE:$CI_REGISTRY_TAG..."
cat <<EOF | kubectl apply -n $KUBE_NAMESPACE --force -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: $name
  namespace: $KUBE_NAMESPACE
  labels:
    track: "$TRACK"
    pipeline_id: "$CI_PIPELINE_ID"
    build_id: "$CI_BUILD_ID"
    tier: api
spec:
  replicas: $replicas
  selector:
    matchLabels:
      tier: api
      track: "$TRACK"
  template:
    metadata:
      labels:
        name: $name
        track: "$TRACK"
        tier: api
    spec:
      imagePullSecrets:
      - name: gitlab-registry-pernament
      containers:
      - name: app
        image: "$CI_REGISTRY_IMAGE:$CI_IMAGE_VERSION"
        imagePullPolicy: Always
        env:
        - name: CI_BUILD_ID
          value: "$CI_BUILD_ID"
        - name: RAILS_SECRET_KEY
          value: "$DJANGO_SECRET_KEY"
        - name: RAILS_DEBUG 
          value: "False"
        - name: RAILS_ALLOWED_HOST
          value: "*"
        - name: RAILS_GCM_KEY
          value: "$GCM_KEY"
        - name: RAILS_CORS_ALLOW_ALL
          value: "True"
        - name: RAILS_CORS_WHITELIST
          value: ""
        - name: RAILS_DB_NAME
          value: "$MYSQL_DATABASE"
        - name: RAILS_DB_USER 
          value: "$MYSQL_USER"
        - name: RAILS_DB_PASS
          value: "$MYSQL_PASSWORD"
        - name: RAILS_DB_HOST
          value: "$mysql_name"
        - name: RAILS_DB_PORT
          value: "3306"
        - name: FCM_SERVER_KEY
          value: "$FCM_SERVER_KEY"
        ports:
        - name: api
          containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: $name
  namespace: $KUBE_NAMESPACE
  labels:
    track: $TRACK
    pipeline_id: "$CI_PIPELINE_ID"
    build_id: "$CI_BUILD_ID"
spec:
  type: NodePort
  ports:
    - name: api
      port: 80
      targetPort: api
  selector:
    track: $TRACK
    tier: api
---
apiVersion: certmanager.k8s.io/v1alpha1
kind: Certificate
metadata:
  name: $name-tls
  namespace: $KUBE_NAMESPACE
spec:
  secretName: $name-tls
  issuerRef:
    name: letsencrypt-prod
    kind: Issuer
  commonName: $URL
  dnsNames:
  - $URL
  acme:
    config:
    - http01:
        ingress: $name
      domains:
      - $URL
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: $name
  namespace: $KUBE_NAMESPACE
  labels:
    track: $TRACK
    pipeline_id: "$CI_PIPELINE_ID"
    build_id: "$CI_BUILD_ID"
  annotations:
    kubernetes.io/ingress.global-static-ip-name: "$IP_NAME"
spec:
  tls:
  - secretName: $name-tls
  rules:
  - host: $URL
    http:
      paths:
      - path: /*
        backend:
          serviceName: $name
          servicePort: 80
EOF

echo "Waiting for deployment..."
kubectl rollout status -n "$KUBE_NAMESPACE" -w "deployment/$name"

echo "Application is accessible at: ${URL}"
echo ""
